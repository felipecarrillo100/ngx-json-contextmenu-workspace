import * as i1$1 from '@angular/cdk/overlay';
import { OverlayModule, OverlayContainer, FullscreenOverlayContainer } from '@angular/cdk/overlay';
import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { EventEmitter, QueryList, Component, ChangeDetectionStrategy, Input, HostBinding, Output, ViewChildren, HostListener, Directive, Optional, Injectable, ElementRef, ViewEncapsulation, ContentChildren, NgModule } from '@angular/core';
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { Subscription, Subject } from 'rxjs';
import { ComponentPortal } from '@angular/cdk/portal';

const evaluateIfFunction = (value, item) => {
    if (value instanceof Function) {
        return value(item);
    }
    return value;
};

const ARROW_LEFT_KEYCODE = 37;
const ARROW_RIGHT_KEYCODE = 39;
/**
 * For testing purpose only
 */
const TESTING_WRAPPER = {
    ActiveDescendantKeyManager,
};
class ContextMenuContentComponent {
    // TODO: should be private but issue in spec with NullInjectorError: No provider for ElementRef!
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        /**
         * The list of `ContextMenuItemDirective` that represent each menu items
         */
        this.menuDirectives = [];
        /**
         * A CSS class to apply a theme to the the menu
         */
        this.menuClass = '';
        /**
         * Wether the instance is a leaf menu or not
         */
        this.isLeaf = false;
        /**
         * Emit when a menu item is selected
         */
        this.execute = new EventEmitter();
        /**
         * Emit when a sub menu is opened
         */
        this.openSubMenu = new EventEmitter();
        /**
         * Emit when a leaf menu is closed
         */
        this.closeLeafMenu = new EventEmitter();
        /**
         * Emit when sub menus are closed
         */
        this.closeSubMenus = new EventEmitter();
        /**
         * Emit when all menus is closed
         */
        this.closeAllMenus = new EventEmitter();
        this.subscription = new Subscription();
    }
    /**
     * @internal
     */
    ngOnInit() {
        this.setupDirectives();
    }
    /**
     * @internal
     */
    ngAfterViewInit() {
        this.overlayRef?.updatePosition();
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * @internal
     */
    onKeyArrowDownOrUp(event) {
        if (!this.isLeaf) {
            return;
        }
        this.keyManager.onKeydown(event);
    }
    /**
     * @internal
     */
    onKeyArrowRight(event) {
        if (!this.isLeaf) {
            return;
        }
        if (this.dir === 'rtl') {
            this.closeActiveItemSubMenu(event);
            return;
        }
        this.openActiveItemSubMenu(event);
    }
    /**
     * @internal
     */
    onKeyArrowLeft(event) {
        if (!this.isLeaf) {
            return;
        }
        if (this.dir === 'rtl') {
            this.openActiveItemSubMenu(event);
            return;
        }
        this.closeActiveItemSubMenu(event);
    }
    /**
     * @internal
     */
    onKeyEnterOrSpace(event) {
        if (!this.isLeaf) {
            return;
        }
        if (!this.keyManager.activeItem) {
            return;
        }
        this.onMenuItemSelect(this.keyManager.activeItem, event);
    }
    /**
     * @internal
     */
    onKeyArrowEscape(event) {
        if (!this.isLeaf) {
            return;
        }
        this.closeActiveItemSubMenu(event);
    }
    /**
     * @internal
     */
    onClickOrRightClick(event) {
        if (event.type === 'click' && event.button === 2) {
            return;
        }
        if (this._elementRef.nativeElement.contains(event.target)) {
            return;
        }
        this.closeAllMenus.emit({ event });
    }
    /**
     * @internal
     */
    stopEvent(event) {
        event.stopPropagation();
    }
    /**
     * @internal
     */
    isMenuItemDisabled(menuItem) {
        return evaluateIfFunction(menuItem.disabled, this.value);
    }
    /**
     * @internal
     */
    isMenuItemVisible(menuItem) {
        return evaluateIfFunction(menuItem.visible, this.value);
    }
    /**
     * @internal
     */
    onOpenSubMenu(menuItem, event) {
        if (!menuItem.subMenu) {
            this.closeSubMenus.next();
        }
        if (this.keyManager.activeItemIndex === null || !menuItem.subMenu) {
            return;
        }
        const anchorElementRef = this.liElementRefs.toArray()[this.keyManager.activeItemIndex];
        const anchorElement = anchorElementRef && anchorElementRef.nativeElement;
        if (anchorElement && event instanceof KeyboardEvent) {
            this.openSubMenu.emit({
                anchoredTo: 'element',
                anchorElement,
                contextMenu: menuItem.subMenu,
                value: this.value,
                parentContextMenu: this,
            });
        }
        else if (event.currentTarget) {
            this.openSubMenu.emit({
                anchoredTo: 'element',
                anchorElement: event.currentTarget,
                contextMenu: menuItem.subMenu,
                value: this.value,
                parentContextMenu: this,
            });
        }
        else {
            this.openSubMenu.emit({
                anchoredTo: 'position',
                x: event.clientX,
                y: event.clientY,
                contextMenu: menuItem.subMenu,
                value: this.value,
            });
        }
    }
    /**
     * @internal
     */
    onMenuItemSelect(menuItem, event) {
        this.cancelEvent(event);
        this.onOpenSubMenu(menuItem, event);
        if (!menuItem.subMenu) {
            this.triggerExecute(menuItem, event);
        }
    }
    triggerExecute(menuItem, event) {
        menuItem.triggerExecute(event, this.value);
    }
    setupDirectives() {
        this.menuDirectives.forEach((menuDirective) => {
            menuDirective.value = this.value;
            this.subscription.add(menuDirective.execute.subscribe((event) => this.execute.emit({ ...event, menuDirective })));
        });
        const queryList = new QueryList();
        queryList.reset(this.menuDirectives);
        this.keyManager = new TESTING_WRAPPER.ActiveDescendantKeyManager(queryList).withWrap();
    }
    openActiveItemSubMenu(event) {
        if (this.keyManager.activeItemIndex === null) {
            return;
        }
        this.cancelEvent(event);
        if (this.keyManager.activeItem) {
            this.onOpenSubMenu(this.keyManager.activeItem, event);
        }
    }
    closeActiveItemSubMenu(event) {
        if (this.keyManager.activeItemIndex === null) {
            return;
        }
        this.cancelEvent(event);
        this.closeLeafMenu.emit({
            excludeRootMenu: this.dir === 'rtl'
                ? event.keyCode === ARROW_RIGHT_KEYCODE
                : event.keyCode === ARROW_LEFT_KEYCODE,
            event,
        });
    }
    cancelEvent(event) {
        if (!event || !event.target) {
            return;
        }
        const target = event.target;
        if (['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName) ||
            target.isContentEditable) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuContentComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.0.0", type: ContextMenuContentComponent, selector: "context-menu-content", inputs: { menuDirectives: "menuDirectives", value: "value", dir: "dir", parentContextMenu: "parentContextMenu", menuClass: "menuClass", overlayRef: "overlayRef", isLeaf: "isLeaf" }, outputs: { execute: "execute", openSubMenu: "openSubMenu", closeLeafMenu: "closeLeafMenu", closeSubMenus: "closeSubMenus", closeAllMenus: "closeAllMenus" }, host: { listeners: { "window:keydown.ArrowDown": "onKeyArrowDownOrUp($event)", "window:keydown.ArrowUp": "onKeyArrowDownOrUp($event)", "window:keydown.ArrowRight": "onKeyArrowRight($event)", "window:keydown.ArrowLeft": "onKeyArrowLeft($event)", "window:keydown.Enter": "onKeyEnterOrSpace($event)", "window:keydown.Space": "onKeyEnterOrSpace($event)", "window:keydown.Escape": "onKeyArrowEscape($event)", "document:click": "onClickOrRightClick($event)", "document:contextmenu": "onClickOrRightClick($event)" }, properties: { "attr.dir": "this.dir" } }, viewQueries: [{ propertyName: "liElementRefs", predicate: ["li"], descendants: true }], ngImport: i0, template: "<div class=\"ngx-contextmenu\" [ngClass]=\"menuClass\" [attr.dir]=\"dir\">\n  <ul #menu class=\"ngx-contextmenu--dropdown-menu\" role=\"menu\" tabindex=\"0\">\n    <li\n      #li\n      *ngFor=\"let menuDirective of menuDirectives; let i = index\"\n      [class.disabled]=\"isMenuItemDisabled(menuDirective)\"\n      [class.divider]=\"menuDirective.divider\"\n      [class.active]=\"\n        menuDirective.isActive && !isMenuItemDisabled(menuDirective)\n      \"\n      [attr.role]=\"menuDirective.divider ? 'separator' : undefined\"\n      role=\"none\"\n    >\n      <hr *ngIf=\"menuDirective.divider\" role=\"separator\" />\n      <button\n        *ngIf=\"!menuDirective.divider && !menuDirective.passive\"\n        type=\"button\"\n        role=\"menuitem\"\n        class=\"ngx-contextmenu--item-content\"\n        [attr.aria-haspopup]=\"!!menuDirective.subMenu\"\n        [class.ngx-contextmenu--parent-menu]=\"!!menuDirective.subMenu\"\n        [class.active]=\"\n          menuDirective.isActive && !isMenuItemDisabled(menuDirective)\n        \"\n        [class.disabled]=\"isMenuItemDisabled(menuDirective)\"\n        [attr.disabled]=\"isMenuItemDisabled(menuDirective) ? 'disabled' : null\"\n        (click)=\"onMenuItemSelect(menuDirective, $event)\"\n        (mouseenter)=\"onOpenSubMenu(menuDirective, $event)\"\n      >\n        <ng-template\n          [ngTemplateOutlet]=\"menuDirective.template\"\n          [ngTemplateOutletContext]=\"{ item: value }\"\n        ></ng-template>\n      </button>\n\n      <span\n        *ngIf=\"!menuDirective.divider && menuDirective.passive\"\n        class=\"ngx-contextmenu--item-content ngx-contextmenu--item-content-passive\"\n        role=\"menuitem\"\n        (click)=\"stopEvent($event)\"\n        (contextmenu)=\"stopEvent($event)\"\n        [class.disabled]=\"isMenuItemDisabled(menuDirective)\"\n      >\n        <ng-template\n          [ngTemplateOutlet]=\"menuDirective.template\"\n          [ngTemplateOutletContext]=\"{ item: value }\"\n        ></ng-template>\n      </span>\n    </li>\n  </ul>\n</div>\n", dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuContentComponent, decorators: [{
            type: Component,
            args: [{ selector: 'context-menu-content', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"ngx-contextmenu\" [ngClass]=\"menuClass\" [attr.dir]=\"dir\">\n  <ul #menu class=\"ngx-contextmenu--dropdown-menu\" role=\"menu\" tabindex=\"0\">\n    <li\n      #li\n      *ngFor=\"let menuDirective of menuDirectives; let i = index\"\n      [class.disabled]=\"isMenuItemDisabled(menuDirective)\"\n      [class.divider]=\"menuDirective.divider\"\n      [class.active]=\"\n        menuDirective.isActive && !isMenuItemDisabled(menuDirective)\n      \"\n      [attr.role]=\"menuDirective.divider ? 'separator' : undefined\"\n      role=\"none\"\n    >\n      <hr *ngIf=\"menuDirective.divider\" role=\"separator\" />\n      <button\n        *ngIf=\"!menuDirective.divider && !menuDirective.passive\"\n        type=\"button\"\n        role=\"menuitem\"\n        class=\"ngx-contextmenu--item-content\"\n        [attr.aria-haspopup]=\"!!menuDirective.subMenu\"\n        [class.ngx-contextmenu--parent-menu]=\"!!menuDirective.subMenu\"\n        [class.active]=\"\n          menuDirective.isActive && !isMenuItemDisabled(menuDirective)\n        \"\n        [class.disabled]=\"isMenuItemDisabled(menuDirective)\"\n        [attr.disabled]=\"isMenuItemDisabled(menuDirective) ? 'disabled' : null\"\n        (click)=\"onMenuItemSelect(menuDirective, $event)\"\n        (mouseenter)=\"onOpenSubMenu(menuDirective, $event)\"\n      >\n        <ng-template\n          [ngTemplateOutlet]=\"menuDirective.template\"\n          [ngTemplateOutletContext]=\"{ item: value }\"\n        ></ng-template>\n      </button>\n\n      <span\n        *ngIf=\"!menuDirective.divider && menuDirective.passive\"\n        class=\"ngx-contextmenu--item-content ngx-contextmenu--item-content-passive\"\n        role=\"menuitem\"\n        (click)=\"stopEvent($event)\"\n        (contextmenu)=\"stopEvent($event)\"\n        [class.disabled]=\"isMenuItemDisabled(menuDirective)\"\n      >\n        <ng-template\n          [ngTemplateOutlet]=\"menuDirective.template\"\n          [ngTemplateOutletContext]=\"{ item: value }\"\n        ></ng-template>\n      </span>\n    </li>\n  </ul>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { menuDirectives: [{
                type: Input
            }], value: [{
                type: Input
            }], dir: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.dir']
            }], parentContextMenu: [{
                type: Input
            }], menuClass: [{
                type: Input
            }], overlayRef: [{
                type: Input
            }], isLeaf: [{
                type: Input
            }], execute: [{
                type: Output
            }], openSubMenu: [{
                type: Output
            }], closeLeafMenu: [{
                type: Output
            }], closeSubMenus: [{
                type: Output
            }], closeAllMenus: [{
                type: Output
            }], liElementRefs: [{
                type: ViewChildren,
                args: ['li']
            }], onKeyArrowDownOrUp: [{
                type: HostListener,
                args: ['window:keydown.ArrowDown', ['$event']]
            }, {
                type: HostListener,
                args: ['window:keydown.ArrowUp', ['$event']]
            }], onKeyArrowRight: [{
                type: HostListener,
                args: ['window:keydown.ArrowRight', ['$event']]
            }], onKeyArrowLeft: [{
                type: HostListener,
                args: ['window:keydown.ArrowLeft', ['$event']]
            }], onKeyEnterOrSpace: [{
                type: HostListener,
                args: ['window:keydown.Enter', ['$event']]
            }, {
                type: HostListener,
                args: ['window:keydown.Space', ['$event']]
            }], onKeyArrowEscape: [{
                type: HostListener,
                args: ['window:keydown.Escape', ['$event']]
            }], onClickOrRightClick: [{
                type: HostListener,
                args: ['document:click', ['$event']]
            }, {
                type: HostListener,
                args: ['document:contextmenu', ['$event']]
            }] } });

class ContextMenuItemDirective {
    /**
     * Is this menu item disabled
     */
    set disabled(disabled) {
        this.#disabled = disabled;
    }
    get disabled() {
        return (this.passive ||
            this.divider ||
            evaluateIfFunction(this.#disabled, this.value));
    }
    #disabled;
    constructor(template) {
        this.template = template;
        /**
         * True to make this menu item a divider
         */
        this.divider = false;
        /**
         * Is this menu item passive (for title)
         */
        this.passive = false;
        /**
         * Is this menu item visible
         */
        this.visible = true;
        /**
         * Emits event and item
         */
        this.execute = new EventEmitter();
        /**
         * @internal
         */
        this.isActive = false;
        this.#disabled = false;
    }
    setActiveStyles() {
        this.isActive = true;
    }
    setInactiveStyles() {
        this.isActive = false;
    }
    /**
     * @internal
     */
    triggerExecute(event, value) {
        if (evaluateIfFunction(this.#disabled, value)) {
            return;
        }
        this.execute.emit({ event, value });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuItemDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.0", type: ContextMenuItemDirective, selector: "[contextMenuItem]", inputs: { subMenu: "subMenu", divider: "divider", disabled: "disabled", passive: "passive", visible: "visible" }, outputs: { execute: "execute" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[contextMenuItem]',
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { subMenu: [{
                type: Input
            }], divider: [{
                type: Input
            }], disabled: [{
                type: Input
            }], passive: [{
                type: Input
            }], visible: [{
                type: Input
            }], execute: [{
                type: Output
            }] } });

const getPositionsToXY = (dir = 'ltr') => {
    if (dir === 'ltr') {
        return [
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'top',
            },
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'bottom',
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'top',
            },
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'top',
            },
            {
                originX: 'end',
                originY: 'center',
                overlayX: 'start',
                overlayY: 'center',
            },
            {
                originX: 'start',
                originY: 'center',
                overlayX: 'end',
                overlayY: 'center',
            },
        ];
    }
    return [
        {
            originX: 'end',
            originY: 'bottom',
            overlayX: 'end',
            overlayY: 'top',
        },
        {
            originX: 'end',
            originY: 'top',
            overlayX: 'end',
            overlayY: 'bottom',
        },
        {
            originX: 'start',
            originY: 'top',
            overlayX: 'end',
            overlayY: 'top',
        },
        {
            originX: 'end',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'top',
        },
        {
            originX: 'start',
            originY: 'center',
            overlayX: 'end',
            overlayY: 'center',
        },
        {
            originX: 'end',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center',
        },
    ];
};
const getPositionsToAnchorElement = (dir = 'ltr') => {
    if (dir === 'ltr') {
        return [
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'top',
            },
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'top',
            },
            {
                originX: 'end',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'bottom',
            },
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'bottom',
            },
        ];
    }
    else {
        return [
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'top',
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'top',
            },
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'bottom',
            },
            {
                originX: 'end',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'bottom',
            },
        ];
    }
};

class ContextMenuStackService {
    constructor() {
        this.stack = [];
    }
    /**
     * Add an item to the stack
     */
    push(value) {
        this.stack.push(value);
    }
    /**
     * Return the stack size
     */
    size() {
        return this.stack.length;
    }
    /**
     * Return true if the stack is empty
     */
    isEmpty() {
        return this.size() === 0;
    }
    /**
     * Clear the whole stack
     */
    closeAll() {
        this.stack.forEach((item) => this.dispose(item));
        this.stack = [];
    }
    /**
     * Detach and dispose sub menu's overlays of the given ContextMenuContentComponent
     */
    destroySubMenus(contextMenu) {
        if (!contextMenu) {
            return;
        }
        const index = this.stack.findIndex(({ overlayRef }) => overlayRef === contextMenu.overlayRef);
        this.stack.slice(index + 1).forEach((item) => {
            this.dispose(item);
        });
    }
    /**
     * Destroy leaf menu and return true if the destroyed menu is the root
     */
    closeLeafMenu(excludeRootMenu) {
        const item = this.disposeLastDetached();
        if (!item) {
            return false;
        }
        const moreThanOneItem = this.size() > 1;
        const isNotEmptyAndDoesNotExcludeRootMenu = !excludeRootMenu && !this.isEmpty();
        if (moreThanOneItem || isNotEmptyAndDoesNotExcludeRootMenu) {
            this.dispose(item);
        }
        if (isNotEmptyAndDoesNotExcludeRootMenu) {
            return true;
        }
        const newValue = this.disposeLastDetached();
        if (newValue) {
            newValue.contextMenuContentComponent.isLeaf = true;
        }
        return false;
    }
    /**
     * Starting by most recent items, dispose all detached item and return the most recent attached one
     */
    disposeLastDetached() {
        let item = this.last();
        if (!item) {
            return;
        }
        while (item &&
            this.size() > 1 &&
            item.overlayRef &&
            this.isDetached(item)) {
            this.dispose(item);
            this.pop();
            item = this.last();
        }
        return item;
    }
    last() {
        if (this.isEmpty()) {
            return;
        }
        return this.stack[this.stack.length - 1];
    }
    pop() {
        const value = this.stack.pop();
        return this.dispose(value);
    }
    isDetached(item) {
        return !item.overlayRef.hasAttached();
    }
    dispose(item) {
        if (item) {
            item.overlayRef.detach();
            item.overlayRef.dispose();
        }
        return item;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuStackService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuStackService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuStackService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * @internal
 */
class ContextMenuEventService {
    constructor() {
        this.onShow = new Subject();
    }
    show(options) {
        this.onShow.next(options);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuEventService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuEventService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuEventService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ContextMenuComponent {
    constructor(overlay, scrollStrategy, contextMenuStack, contextMenuEventService) {
        this.overlay = overlay;
        this.scrollStrategy = scrollStrategy;
        this.contextMenuStack = contextMenuStack;
        this.contextMenuEventService = contextMenuEventService;
        /**
         * A CSS class to apply to the context menu overlay, ideal for theming and custom styling
         */
        this.menuClass = '';
        /**
         * Disable the whole context menu
         */
        this.disabled = false;
        /**
         * Emit when the menu is opened
         */
        this.open = new EventEmitter();
        /**
         * Emit when the menu is closed
         */
        this.close = new EventEmitter();
        /**
         * @internal
         */
        this.visibleMenuItems = [];
        this.subscription = new Subscription();
    }
    /**
     * @internal
     */
    ngOnInit() {
        const subscription = this.contextMenuEventService.onShow.subscribe((menuEvent) => {
            this.onMenuEvent(menuEvent);
        });
        this.subscription.add(subscription);
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * Open context menu
     */
    openContextMenu(context) {
        let positionStrategy;
        if (context.anchoredTo === 'position') {
            positionStrategy = this.overlay
                .position()
                .flexibleConnectedTo({
                x: context.x,
                y: context.y,
            })
                .withPositions(getPositionsToXY(context.dir));
            this.closeAllContextMenus();
        }
        else {
            const { anchorElement, parentContextMenu } = context;
            positionStrategy = this.overlay
                .position()
                .flexibleConnectedTo(new ElementRef(anchorElement))
                .withPositions(getPositionsToAnchorElement(parentContextMenu.dir));
            this.contextMenuStack.destroySubMenus(parentContextMenu);
        }
        const overlayRef = this.overlay.create({
            positionStrategy,
            panelClass: 'ngx-contextmenu',
            scrollStrategy: this.scrollStrategy.close(),
        });
        this.attachContextMenu(overlayRef, context);
    }
    onMenuEvent(event) {
        if (this.disabled) {
            return;
        }
        const { contextMenu, value } = event;
        if (contextMenu && contextMenu !== this) {
            return;
        }
        this.value = value;
        this.setVisibleMenuItems();
        this.openContextMenu({
            ...event,
            menuItemDirectives: this.visibleMenuItems,
            menuClass: this.menuClass,
            dir: this.dir,
        });
        this.open.next(event);
    }
    attachContextMenu(overlayRef, context) {
        const { value, menuItemDirectives } = context;
        const contextMenuContentRef = overlayRef.attach(new ComponentPortal(ContextMenuContentComponent));
        const { instance: contextMenuContentComponent } = contextMenuContentRef;
        contextMenuContentComponent.value = value;
        contextMenuContentComponent.menuDirectives = menuItemDirectives;
        contextMenuContentComponent.overlayRef = overlayRef;
        contextMenuContentComponent.isLeaf = true;
        contextMenuContentComponent.menuClass = this.getMenuClass(context);
        contextMenuContentComponent.dir = this.getDir(context);
        this.contextMenuStack.push({
            overlayRef,
            contextMenuContentComponent,
        });
        const subscriptions = new Subscription();
        subscriptions.add(contextMenuContentComponent.execute.subscribe(() => this.closeAllContextMenus()));
        subscriptions.add(contextMenuContentComponent.closeAllMenus.subscribe(() => this.closeAllContextMenus()));
        subscriptions.add(contextMenuContentComponent.closeLeafMenu.subscribe((closeLeafMenuEvent) => this.destroyLeafMenu(!!closeLeafMenuEvent.excludeRootMenu)));
        subscriptions.add(contextMenuContentComponent.openSubMenu.subscribe((openSubMenuEvent) => {
            this.contextMenuStack.destroySubMenus(contextMenuContentComponent);
            if (!openSubMenuEvent.contextMenu) {
                contextMenuContentComponent.isLeaf = true;
                return;
            }
            contextMenuContentComponent.isLeaf = false;
            this.contextMenuEventService.show(openSubMenuEvent);
        }));
        subscriptions.add(contextMenuContentComponent.closeSubMenus.subscribe(() => {
            this.contextMenuStack.destroySubMenus(contextMenuContentComponent);
        }));
        contextMenuContentRef.onDestroy(() => {
            this.close.next();
            menuItemDirectives.forEach((menuItem) => (menuItem.isActive = false));
            subscriptions.unsubscribe();
        });
        contextMenuContentRef.changeDetectorRef.detectChanges();
    }
    getMenuClass(event) {
        return (event.menuClass ||
            (event.anchoredTo === 'element' && event?.parentContextMenu?.menuClass) ||
            '');
    }
    getDir(event) {
        return (event.dir ||
            (event.anchoredTo === 'element' && event?.parentContextMenu?.dir) ||
            undefined);
    }
    closeAllContextMenus() {
        this.contextMenuStack.closeAll();
    }
    destroyLeafMenu(excludeRootMenu) {
        this.contextMenuStack.closeLeafMenu(excludeRootMenu);
    }
    isMenuItemVisible(menuItem) {
        return evaluateIfFunction(menuItem.visible, this.value);
    }
    setVisibleMenuItems() {
        this.visibleMenuItems = this.menuItems.filter((menuItem) => this.isMenuItemVisible(menuItem));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuComponent, deps: [{ token: i1$1.Overlay }, { token: i1$1.ScrollStrategyOptions }, { token: ContextMenuStackService }, { token: ContextMenuEventService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.0.0", type: ContextMenuComponent, selector: "context-menu", inputs: { menuClass: "menuClass", disabled: "disabled", dir: "dir" }, outputs: { open: "open", close: "close" }, queries: [{ propertyName: "menuItems", predicate: ContextMenuItemDirective }], ngImport: i0, template: '', isInline: true, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuComponent, decorators: [{
            type: Component,
            args: [{
                    encapsulation: ViewEncapsulation.None,
                    selector: 'context-menu',
                    template: '',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.Overlay }, { type: i1$1.ScrollStrategyOptions }, { type: ContextMenuStackService }, { type: ContextMenuEventService }]; }, propDecorators: { menuClass: [{
                type: Input
            }], disabled: [{
                type: Input
            }], dir: [{
                type: Input
            }], open: [{
                type: Output
            }], close: [{
                type: Output
            }], menuItems: [{
                type: ContentChildren,
                args: [ContextMenuItemDirective]
            }] } });

class ContextMenuDirective {
    constructor(contextMenuEventService, elementRef, contextMenuStackService) {
        this.contextMenuEventService = contextMenuEventService;
        this.elementRef = elementRef;
        this.contextMenuStackService = contextMenuStackService;
        /**
         * The directive must have a tabindex for being accessible
         */
        this.tabindex = '0';
        /**
         * Accessibility
         *
         * @internal
         */
        this.ariaHasPopup = 'true';
    }
    /**
     * Programmatically open the context menu
     */
    open(event) {
        if (!this.canOpen()) {
            return;
        }
        if (event instanceof MouseEvent) {
            this.onContextMenu(event);
            return;
        }
        const { x, y, height } = this.elementRef.nativeElement.getBoundingClientRect();
        this.contextMenuEventService.show({
            anchoredTo: 'position',
            x,
            y: y + height,
            contextMenu: this.contextMenu,
            value: this.contextMenuValue,
        });
    }
    /**
     * Programmatically close the context menu
     */
    close() {
        this.contextMenuStackService.closeAll();
    }
    /**
     * @internal
     */
    onContextMenu(event) {
        if (!this.canOpen()) {
            return;
        }
        this.contextMenuEventService.show({
            anchoredTo: 'position',
            contextMenu: this.contextMenu,
            x: event.clientX,
            y: event.clientY,
            value: this.contextMenuValue,
        });
        event.preventDefault();
        event.stopPropagation();
    }
    canOpen() {
        return this.contextMenu && !this.contextMenu.disabled;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuDirective, deps: [{ token: ContextMenuEventService }, { token: i0.ElementRef }, { token: ContextMenuStackService }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.0", type: ContextMenuDirective, selector: "[contextMenu]", inputs: { contextMenuValue: "contextMenuValue", contextMenu: "contextMenu", tabindex: "tabindex" }, host: { listeners: { "contextmenu": "onContextMenu($event)" }, properties: { "attr.tabindex": "this.tabindex", "attr.aria-haspopup": "this.ariaHasPopup" } }, exportAs: ["ngxContextMenu"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[contextMenu]',
                    exportAs: 'ngxContextMenu',
                }]
        }], ctorParameters: function () { return [{ type: ContextMenuEventService }, { type: i0.ElementRef }, { type: ContextMenuStackService }]; }, propDecorators: { contextMenuValue: [{
                type: Input
            }], contextMenu: [{
                type: Input
            }], tabindex: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.tabindex']
            }], ariaHasPopup: [{
                type: HostBinding,
                args: ['attr.aria-haspopup']
            }], onContextMenu: [{
                type: HostListener,
                args: ['contextmenu', ['$event']]
            }] } });

class ContextMenuModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuModule, declarations: [ContextMenuDirective,
            ContextMenuComponent,
            ContextMenuContentComponent,
            ContextMenuItemDirective], imports: [CommonModule, OverlayModule], exports: [ContextMenuDirective,
            ContextMenuComponent,
            ContextMenuItemDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuModule, providers: [
            { provide: OverlayContainer, useClass: FullscreenOverlayContainer },
        ], imports: [CommonModule, OverlayModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        ContextMenuDirective,
                        ContextMenuComponent,
                        ContextMenuContentComponent,
                        ContextMenuItemDirective,
                    ],
                    providers: [
                        { provide: OverlayContainer, useClass: FullscreenOverlayContainer },
                    ],
                    exports: [
                        ContextMenuDirective,
                        ContextMenuComponent,
                        ContextMenuItemDirective,
                    ],
                    imports: [CommonModule, OverlayModule],
                }]
        }] });

/**
 * Programmatically open a ContextMenuComponent to a X/Y position
 */
class ContextMenuService {
    constructor(contextMenuEventService, contextMenuStackService) {
        this.contextMenuEventService = contextMenuEventService;
        this.contextMenuStackService = contextMenuStackService;
    }
    /**
     * Show the given `ContextMenuComponent` at a specified X/Y position
     */
    show(contextMenu, options = { x: 0, y: 0 }) {
        this.contextMenuEventService.show({
            anchoredTo: 'position',
            contextMenu,
            value: options.value,
            x: options.x,
            y: options.y,
        });
    }
    /**
     * Close all open `ContextMenuComponent`
     */
    closeAll() {
        this.contextMenuStackService.closeAll();
    }
    /**
     * Return true if any `ContextMenuComponent` is open
     */
    hasOpenMenu() {
        return !this.contextMenuStackService.isEmpty();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuService, deps: [{ token: ContextMenuEventService }, { token: ContextMenuStackService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: ContextMenuEventService }, { type: ContextMenuStackService }]; } });

/*
 * Public API Surface of @perfectmemory/ngx-contextmenu
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ContextMenuComponent, ContextMenuDirective, ContextMenuItemDirective, ContextMenuModule, ContextMenuService };
//# sourceMappingURL=perfectmemory-ngx-contextmenu.mjs.map

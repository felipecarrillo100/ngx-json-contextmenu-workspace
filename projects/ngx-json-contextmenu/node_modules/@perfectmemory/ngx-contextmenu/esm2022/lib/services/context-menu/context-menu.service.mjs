import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "../context-menu-event/context-menu-event.service";
import * as i2 from "../context-menu-stack/context-menu-stack.service";
/**
 * Programmatically open a ContextMenuComponent to a X/Y position
 */
export class ContextMenuService {
    constructor(contextMenuEventService, contextMenuStackService) {
        this.contextMenuEventService = contextMenuEventService;
        this.contextMenuStackService = contextMenuStackService;
    }
    /**
     * Show the given `ContextMenuComponent` at a specified X/Y position
     */
    show(contextMenu, options = { x: 0, y: 0 }) {
        this.contextMenuEventService.show({
            anchoredTo: 'position',
            contextMenu,
            value: options.value,
            x: options.x,
            y: options.y,
        });
    }
    /**
     * Close all open `ContextMenuComponent`
     */
    closeAll() {
        this.contextMenuStackService.closeAll();
    }
    /**
     * Return true if any `ContextMenuComponent` is open
     */
    hasOpenMenu() {
        return !this.contextMenuStackService.isEmpty();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuService, deps: [{ token: i1.ContextMenuEventService }, { token: i2.ContextMenuStackService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: ContextMenuService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ContextMenuEventService }, { type: i2.ContextMenuStackService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC1tZW51LnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtY29udGV4dG1lbnUvc3JjL2xpYi9zZXJ2aWNlcy9jb250ZXh0LW1lbnUvY29udGV4dC1tZW51LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7OztBQWtDM0M7O0dBRUc7QUFJSCxNQUFNLE9BQU8sa0JBQWtCO0lBQzdCLFlBQW9CLHVCQUFtRCxFQUNuRCx1QkFBbUQ7UUFEbkQsNEJBQXVCLEdBQXZCLHVCQUF1QixDQUE0QjtRQUNuRCw0QkFBdUIsR0FBdkIsdUJBQXVCLENBQTRCO0lBQUcsQ0FBQztJQUMzRTs7T0FFRztJQUNJLElBQUksQ0FDVCxXQUFvQyxFQUNwQyxVQUErQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUU3RCxJQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDO1lBQ2hDLFVBQVUsRUFBRSxVQUFVO1lBQ3RCLFdBQVc7WUFDWCxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUs7WUFDcEIsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ1osQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ2IsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0ksUUFBUTtRQUNiLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxXQUFXO1FBQ2hCLE9BQU8sQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDakQsQ0FBQzs4R0EvQlUsa0JBQWtCO2tIQUFsQixrQkFBa0IsY0FGakIsTUFBTTs7MkZBRVAsa0JBQWtCO2tCQUg5QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRleHRNZW51Q29tcG9uZW50IH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9jb250ZXh0LW1lbnUvY29udGV4dC1tZW51LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb250ZXh0TWVudUV2ZW50U2VydmljZSB9IGZyb20gJy4uL2NvbnRleHQtbWVudS1ldmVudC9jb250ZXh0LW1lbnUtZXZlbnQuc2VydmljZSc7XG5pbXBvcnQgeyBDb250ZXh0TWVudVN0YWNrU2VydmljZSB9IGZyb20gJy4uL2NvbnRleHQtbWVudS1zdGFjay9jb250ZXh0LW1lbnUtc3RhY2suc2VydmljZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGV4dE1lbnVPcGVuQXRQb3NpdGlvbk9wdGlvbnM8VD4ge1xuICAvKipcbiAgICogT3B0aW9uYWwgYXNzb2NpYXRlZCBkYXRhIHRvIHRoZSBjb250ZXh0IG1lbnUsIHdpbGwgYmUgZW1pdHRlZCB3aGVuIGEgbWVudSBpdGVtIGlzIHNlbGVjdGVkXG4gICAqL1xuICB2YWx1ZT86IFQ7XG4gIC8qKlxuICAgKiBUaGUgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgbWVudVxuICAgKi9cbiAgeDogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBtZW51XG4gICAqL1xuICB5OiBudW1iZXI7XG59XG5leHBvcnQgaW50ZXJmYWNlIENvbnRleHRNZW51T3BlbkF0RWxlbWVudE9wdGlvbnM8VD4ge1xuICAvKipcbiAgICogT3B0aW9uYWwgYXNzb2NpYXRlZCBkYXRhIHRvIHRoZSBjb250ZXh0IG1lbnUsIHdpbGwgYmUgZW1pdHRlZCB3aGVuIGEgbWVudSBpdGVtIGlzIHNlbGVjdGVkXG4gICAqL1xuICB2YWx1ZT86IFQ7XG4gIC8qKlxuICAgKiBUaGUgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgbWVudVxuICAgKi9cbiAgeDogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBtZW51XG4gICAqL1xuICB5OiBudW1iZXI7XG59XG5cbi8qKlxuICogUHJvZ3JhbW1hdGljYWxseSBvcGVuIGEgQ29udGV4dE1lbnVDb21wb25lbnQgdG8gYSBYL1kgcG9zaXRpb25cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIENvbnRleHRNZW51U2VydmljZTxUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29udGV4dE1lbnVFdmVudFNlcnZpY2U6IENvbnRleHRNZW51RXZlbnRTZXJ2aWNlPFQ+LFxuICAgICAgICAgICAgICBwcml2YXRlIGNvbnRleHRNZW51U3RhY2tTZXJ2aWNlOiBDb250ZXh0TWVudVN0YWNrU2VydmljZTxUPikge31cbiAgLyoqXG4gICAqIFNob3cgdGhlIGdpdmVuIGBDb250ZXh0TWVudUNvbXBvbmVudGAgYXQgYSBzcGVjaWZpZWQgWC9ZIHBvc2l0aW9uXG4gICAqL1xuICBwdWJsaWMgc2hvdyhcbiAgICBjb250ZXh0TWVudTogQ29udGV4dE1lbnVDb21wb25lbnQ8VD4sXG4gICAgb3B0aW9uczogQ29udGV4dE1lbnVPcGVuQXRQb3NpdGlvbk9wdGlvbnM8VD4gPSB7IHg6IDAsIHk6IDAgfVxuICApIHtcbiAgICB0aGlzLmNvbnRleHRNZW51RXZlbnRTZXJ2aWNlLnNob3coe1xuICAgICAgYW5jaG9yZWRUbzogJ3Bvc2l0aW9uJyxcbiAgICAgIGNvbnRleHRNZW51LFxuICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICB4OiBvcHRpb25zLngsXG4gICAgICB5OiBvcHRpb25zLnksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgYWxsIG9wZW4gYENvbnRleHRNZW51Q29tcG9uZW50YFxuICAgKi9cbiAgcHVibGljIGNsb3NlQWxsKCk6IHZvaWQge1xuICAgIHRoaXMuY29udGV4dE1lbnVTdGFja1NlcnZpY2UuY2xvc2VBbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBhbnkgYENvbnRleHRNZW51Q29tcG9uZW50YCBpcyBvcGVuXG4gICAqL1xuICBwdWJsaWMgaGFzT3Blbk1lbnUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLmNvbnRleHRNZW51U3RhY2tTZXJ2aWNlLmlzRW1wdHkoKTtcbiAgfVxufVxuIl19